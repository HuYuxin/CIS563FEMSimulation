//
// Created by yuxinhu on 2/19/18.
//

#include <Eigen/Core>
#include <Eigen/Dense>

#include <fstream>
#include <sstream>
#include <vector>
#include <iostream>
#include <eigen3/Eigen/src/Core/Matrix.h>

using Eigen::MatrixXd;


class particle{
public:
    double posx;
    double posy;
    double posz;
    double mass;
    double velx;
    double vely;
    double velz;
    double fx;
    double fy;
    double fz;
    particle(double a, double b, double c):posx(a), posy(b), posz(c){
        mass = 0.01;
        velx = 0.0;
        vely = 0.0;
        velz = 0.0;
        fx = 0.0;
        fy = 0.0;
        fz = 0.0;
    }
};



class tetrahedral{
public:
    int pIndex[4];

    MatrixXd Dm;
    MatrixXd DmInverse;
    double volume;

    tetrahedral(int p1, int p2, int p3, int p4){
        pIndex[0] = p1;
        pIndex[1] = p2;
        pIndex[2] = p3;
        pIndex[3] = p4;
    }

};


//Parse the result .vtk file generated by tetGen program
bool parseFile(std::string fileName, std::vector<particle>& particles, std::vector<std::pair<int, int>>& edges,
                std::vector<tetrahedral>& tetrahedrals){
    bool result = false;
    std::ifstream infile(fileName);
    std::string line;
    int totalPoints = -1;
    int totalTetra = -1;
    if(infile.fail()){
        infile.close();
        return result;
    }

    while(std::getline(infile, line)){
        std::istringstream iss(line);
        if(totalPoints > 0){
            double x;
            iss >> x;
            double y;
            iss >> y;
            double z;
            iss >> z;
            particle p(x,y,z);
            particles.push_back(p);
            totalPoints --;
        }else if(totalTetra > 0){
            int totalP = 0;
            iss >> totalP;
            std::vector<int> edgeP;
            while(totalP > 0){
                int p = 0;
                iss>>p;
                edgeP.push_back(p+1); //the index stored in .vtk file stars counting from 0, where in .poly file index starts counting from 1
                totalP--;
            }
            tetrahedral Ti(0,0,0,0);
            for(unsigned int i=0; i<edgeP.size()-1; i++) {
                for (unsigned int j = i + 1; j < edgeP.size(); j++) {
                    edges.push_back(std::pair<int, int>(edgeP[i], edgeP[j]));
                }
                //tetrahedral.push_back(edgeP[i]);
                Ti.pIndex[i] = edgeP[i];
            }
            //***************TODO: Calculate Dm, DmInverse, and Volume of each tetrahedral****************//


            tetrahedrals.push_back(Ti);
            totalTetra--;
        }else{
            std::string firstWord = "";
            iss >> firstWord;
            if(firstWord == "POINTS"){
                iss >> totalPoints;
            }
            if(firstWord == "CELLS"){
                iss >> totalTetra;
            }else{
                continue;
            }
        }

    }
    infile.close();
    result = true;
    return result;
}

//Write the parse result into .poly file so we can load it into Houdini to check the tetrahedral result
bool writePolyFile(std::string fileName, std::vector<particle>& particles, std::vector<std::pair<int, int>>& edges){
    bool result = false;
    std::ofstream myfile;
    myfile.open (fileName);
    if(myfile.fail()){
        myfile.close();
        return result;
    }
    myfile << "POINTS\n";
    for(unsigned int i=0; i<particles.size(); i++){
        myfile << std::to_string(i+1)<<":"
               <<" "<<particles[i].posx
               <<" "<<particles[i].posy
               <<" "<<particles[i].posz<<"\n";
    }
    myfile<<"POLYS\n";
    for(unsigned int i=0; i<edges.size(); i++){
        myfile<<std::to_string(i+1)<<":";
        myfile << " "<<std::to_string(edges[i].first);
        myfile << " "<<std::to_string(edges[i].second);
        myfile<<"\n";

    }
    myfile<<"END\n";
    myfile.close();
    result = true;
    return result;
}

void evaluateForce(std::vector<tetrahedral>& tetrahedrals, std::vector<particle>& particles){
    //TODO:evaluate force on each tetrahedral
}

void updateParticles(std::vector<particle>& particles, float simulationTimeStep){
    //TODO: update particles position and velocity
}

void writeBgeoFile(std::vector<particle>& particles, std::string fileName){
   //TODO: write the particle position and velocity in bgeo file
}

int main(int argc, char* argv[]){
    std::vector<particle> particles;
    std::vector<std::pair<int, int>> edges;
    std::vector<tetrahedral> tetrahedrals;

    //Parse the result .vtk file generated by tetGen program
    if(!parseFile("cubeTest.1.vtk", particles, edges, tetrahedrals)){
        std::cout<<"file parse error!! check the vtk file"<<std::endl;
        return 0;
    }

    //Write the parse result into .poly file so we can load it into Houdini to check the tetrahedral result
    if(!writePolyFile("cubeTestOutput.poly", particles, edges)){
        std::cout<<"write poly file error!! check the .poly file"<<std::endl;
    }


    //Start Simulation
    //Simulate 24 frames per second, let's run 10 seconds, so 240 frames in total.
    //For each frame, we take 10 timeStep, total of 2400 timeStep
    int simulationTime = 30; //Seconds
    int framesPerSecond = 24;
    int timeStepCountPerFrame = 30;
    float simulationTimeStep = (1.0/framesPerSecond)/simulationTime;
    int totalTimeStep = timeStepCountPerFrame * framesPerSecond * simulationTime;
    int frameNum = 0;
    for(int i=0; i < totalTimeStep; i=i + timeStepCountPerFrame){
        for(int j=i; j < i+timeStepCountPerFrame; j++){
            //*************TODO: eveluate force on each tetrahedral************//
            evaluateForce(tetrahedrals, particles);



            //*************TODO: update particle velocity and position*********//
            updateParticles(particles, simulationTimeStep);


            //*************TODO: boundary and collision checking************//


        }

        //*************TODO: write the particle position and velocity in bgeo file***********//
        writeBgeoFile(particles, "femsimulation"+std::to_string(frameNum)+".bgeo");
        frameNum++;
    }
    return 0;
}