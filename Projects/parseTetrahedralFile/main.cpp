//
// Created by yuxinhu on 2/19/18.
//

#include <Eigen/Core>
#include <Eigen/Dense>
#include <Eigen/LU>
#include <Partio.h>
#include <fstream>
#include <sstream>
#include <vector>
#include <iostream>
#include <eigen3/Eigen/src/Core/Matrix.h>

using Eigen::MatrixXd;


// collision plane
#define Y_COLLISION_PLANE -10.0

// TODO: adjust this number to compare, (the smaller, the softer, if larget, cube will collapse)
#define CUBE_DENSITY 2.0

//Added by Yuxin for force model comparason
enum ForceModel { LINEAR, SVKIRCHHOFF, COROTATED, NEOHOOKEAN };

class particle{
public:
    float posx;
    float posy;
    float posz;
    float mass;
    float velx;
    float vely;
    float velz;
    float fx;
    float fy;
    float fz;

    particle(float a, float b, float c):posx(a), posy(b), posz(c){
        mass = 0.0;
        velx = 0.0;
        vely = 0.0;
        velz = 0.0;
        fx = 0.0;
        fy = 0.0;
        fz = 0.0;
    }
};



class tetrahedral{
public:
    int pIndex[4];

    Eigen::Matrix<float,3,3> Dm;
    Eigen::Matrix<float,3,3> DmInverse;
    float volume;

    tetrahedral(int p1, int p2, int p3, int p4){
        pIndex[0] = p1;
        pIndex[1] = p2;
        pIndex[2] = p3;
        pIndex[3] = p4;

        Dm = Eigen::Matrix<float,3,3>::Identity();
        DmInverse = Eigen::Matrix<float,3,3>::Identity();
        volume = 0.0f;
    }

};


//Parse the result .vtk file generated by tetGen program
bool parseFile(std::string fileName, std::vector<particle>& particles, std::vector<std::pair<int, int>>& edges,
               std::vector<tetrahedral>& tetrahedrals){
    bool result = false;
    std::ifstream infile(fileName);
    std::string line;
    int totalPoints = -1;
    int totalTetra = -1;
    if(infile.fail()){
        infile.close();
        return result;
    }

    while(std::getline(infile, line)){
        std::istringstream iss(line);
        if(totalPoints > 0){
            float x;
            iss >> x;
            float y;
            iss >> y;
            float z;
            iss >> z;
            particle p(x,y,z);
            particles.push_back(p);
            totalPoints --;
        }else if(totalTetra > 0){
            int totalP = 0;
            iss >> totalP;
            std::vector<int> edgeP;
            while(totalP > 0){
                int p = 0;
                iss>>p;
                edgeP.push_back(p+1); //the index stored in .vtk file stars counting from 0, where in .poly file index starts counting from 1
                totalP--;
            }
            tetrahedral Ti(0,0,0,0);
            for(unsigned int i=0; i<edgeP.size(); i++) {
                for (unsigned int j = i + 1; j < edgeP.size(); j++) {
                    edges.push_back(std::pair<int, int>(edgeP[i], edgeP[j]));
                }
                //tetrahedral.push_back(edgeP[i]);
                Ti.pIndex[i] = edgeP[i]-1;
            }

            //***************TODO: Calculate Dm, DmInverse, and Volume of each tetrahedral****************//
            particle& i = particles[Ti.pIndex[0]];
            particle& j = particles[Ti.pIndex[1]];
            particle& k = particles[Ti.pIndex[2]];
            particle& l = particles[Ti.pIndex[3]];
            Eigen::Matrix<float,3,3> Dm;

            Dm(0, 0) = i.posx - l.posx;
            Dm(1, 0) = i.posy - l.posy;
            Dm(2, 0) = i.posz - l.posz;
            Dm(0, 1) = j.posx - l.posx;
            Dm(1, 1) = j.posy - l.posy;
            Dm(2, 1) = j.posz - l.posz;
            Dm(0, 2) = k.posx - l.posx;
            Dm(1, 2) = k.posy - l.posy;
            Dm(2, 2) = k.posz - l.posz;



            Ti.Dm = Dm;
            // float a = Dm.determinant();
            // std::cout<<"a is: "<<a<<std::endl;
            Ti.DmInverse = Dm.inverse();

            Ti.volume = 1.0/6.0 * std::fabs(Dm.determinant());
            if (Ti.volume < 0.f)
            {
                std::cout << Ti.volume << std::endl;
            }


            // calculate mass based on density and volume
            i.mass += CUBE_DENSITY * Ti.volume * 0.25;
            j.mass += CUBE_DENSITY * Ti.volume * 0.25;
            k.mass += CUBE_DENSITY * Ti.volume * 0.25;
            l.mass += CUBE_DENSITY * Ti.volume * 0.25;
            // ***********************************************************************************

            tetrahedrals.push_back(Ti);
            totalTetra--;
        }else{
            std::string firstWord = "";
            iss >> firstWord;
            if(firstWord == "POINTS"){
                iss >> totalPoints;
            }
            if(firstWord == "CELLS"){
                iss >> totalTetra;
            }else{
                continue;
            }
        }

    }
    infile.close();
    result = true;
    return result;
}

bool parseFaceFile(std::string fileName, std::vector<std::tuple<int, int, int>>& faces){
    bool result = false;
    std::ifstream infile(fileName);
    std::string line;
    if(infile.fail()){
        infile.close();
        return result;
    }

    //Read the first line
    std::getline(infile, line);
    std::istringstream iss1(line);
    int faceNum;
    iss1 >> faceNum;

    while(faceNum>0){
        if(!std::getline(infile, line)){
            std::cout<<"not enough faces read from the file, check .face file!"<<std::endl;
            break;
        }
        std::istringstream iss(line);
        int faceIndex = 0;
        iss>>faceIndex;
        int faceParticleIndex1 = 0;
        iss>>faceParticleIndex1;
        int faceParticleIndex2 = 0;
        iss>>faceParticleIndex2;
        int faceParticleIndex3 = 0;
        iss>>faceParticleIndex3;
        faces.push_back(std::tuple<int, int, int>(faceParticleIndex1, faceParticleIndex2, faceParticleIndex3));
        faceNum--;
    }
    infile.close();
    result = true;
    return result;
}

//Write the parse result into .poly file so we can load it into Houdini to check the tetrahedral result
bool writePolyFile(std::string fileName, std::vector<particle>& particles, std::vector<std::pair<int, int>>& edges){
    bool result = false;
    std::ofstream myfile;
    myfile.open (fileName);
    if(myfile.fail()){
        myfile.close();
        return result;
    }
    myfile << "POINTS\n";
    for(unsigned int i=0; i<particles.size(); i++){
        myfile << std::to_string(i+1)<<":"
               <<" "<<particles[i].posx
               <<" "<<particles[i].posy
               <<" "<<particles[i].posz<<"\n";
    }
    myfile<<"POLYS\n";
    for(unsigned int i=0; i<edges.size(); i++){
        myfile<<std::to_string(i+1)<<":";
        myfile << " "<<std::to_string(edges[i].first);
        myfile << " "<<std::to_string(edges[i].second);
        myfile<<"\n";

    }
    myfile<<"END\n";
    myfile.close();
    result = true;
    return result;
}

bool writeObjFile(std::string fileName, std::vector<particle>& particles, std::vector<std::tuple<int, int, int>>& faces){
    bool result = false;
    std::ofstream myfile;
    myfile.open (fileName);
    if(myfile.fail()){
        myfile.close();
        return result;
    }

    for(unsigned int i=0; i<particles.size(); i++){
        myfile << "v"
               <<" "<<particles[i].posx
               <<" "<<particles[i].posy
               <<" "<<particles[i].posz<<"\n";
    }
    myfile<<"\n";
    for(unsigned int i=0; i<faces.size(); i++){
        myfile<<"f";
        myfile << " "<<std::to_string(std::get<0>(faces[i]));
        myfile << " "<<std::to_string(std::get<1>(faces[i]));
        myfile << " "<<std::to_string(std::get<2>(faces[i]));

        myfile<<"\n";

    }
    myfile.close();
    result = true;
    return result;
}

//Added by Yuxin for Debug Purpose
void printParticlePosition(std::vector<particle>& particles, std::string message){
    for(unsigned int i=0; i<1; i++){
        std::cout<<message<<" particle "<<i<<" pos is: "<<particles[i].posx<<" "<<particles[i].posy<<" "<<particles[i].posz<<std::endl;
        std::cout<<message<<"particle "<<i<<" force is: "<<particles[i].fx<<" "<<particles[i].fy<<" "<<particles[i].fz<<std::endl;
        std::cout<<message<<"particle "<<i<<" vel is: "<<particles[i].velx<<" "<<particles[i].vely<<" "<<particles[i].velz<<std::endl;
    }
}


/// Added by Yuxin for Debug Purpose, checking each tetrahedral after running TetGen
bool writeIndividualPolyFile(std::string fileName, std::vector<particle>& particles, std::vector<tetrahedral>& tetras){
    bool result = false;
    for(unsigned int i=0; i<tetras.size(); i++){
        std::ofstream myfile;
        std::string fileNamei = fileName + std::to_string(i+1)+".POLY";
        myfile.open (fileNamei);
        if(myfile.fail()){
            myfile.close();
            return result;
        }
        myfile << "POINTS\n";
        for(unsigned int i=0; i<particles.size(); i++){
            myfile << std::to_string(i+1)<<":"
                   <<" "<<particles[i].posx
                   <<" "<<particles[i].posy
                   <<" "<<particles[i].posz<<"\n";
        }
        myfile<<"POLYS\n";
        int edgeNumber = 0;
        for(unsigned int particleIndex=0; particleIndex<4; particleIndex++){
            for(unsigned int particleIndex2 = particleIndex+1; particleIndex2<4; particleIndex2++){
                myfile<<std::to_string(edgeNumber+1)<<":";
                myfile<<" "<<std::to_string(tetras[i].pIndex[particleIndex]);
                myfile<<" "<<std::to_string(tetras[i].pIndex[particleIndex2]);
                myfile<<"\n";
                edgeNumber++;
            }
        }
        myfile<<"END\n";
        myfile.close();
    }
    result = true;
    return result;
}

Eigen::Matrix<float,3,3> pFunction(Eigen::Matrix<float,3,3> F)
{
    //SVD
    Eigen::JacobiSVD<Eigen::Matrix<float,3,3>> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
    Eigen::Matrix<float,3,3> U = svd.matrixU();
    Eigen::Matrix<float,3,3> V = svd.matrixV();
    Eigen::Matrix<float,3,3> R = U * V.transpose();
    float miu = 1.0; float namuda = 1.0;
    float J = F.determinant();
    Eigen::Matrix<float,3,3> P = miu * (F - R) + namuda * (J - 1) * J * F.inverse();
    return P;
}



void evaluateForce(std::vector<tetrahedral>& tetrahedrals, std::vector<particle>& particles, ForceModel forceModel){
    //TODO:evaluate force on each tetrahedral

    //First need to set all F to be zero or only gravity;
    const int particlessize = particles.size();
    for(int index = 0; index < particlessize; index++)
    {
        particles[index].fx = 0.0;
        particles[index].fy = -9.8 * particles[index].mass;
        particles[index].fz = 0.0;
    }
    const int tetrahedralssize = tetrahedrals.size();
    for(int index = 0; index < tetrahedralssize; index++)
    {
        particle i = particles[tetrahedrals[index].pIndex[0]];
        particle j = particles[tetrahedrals[index].pIndex[1]];
        particle k = particles[tetrahedrals[index].pIndex[2]];
        particle l = particles[tetrahedrals[index].pIndex[3]];
        Eigen::Matrix<float,3,3> Ds;

        Ds(0, 0) = i.posx - l.posx;
        Ds(1, 0) = i.posy - l.posy;
        Ds(2, 0) = i.posz - l.posz;
        Ds(0, 1) = j.posx - l.posx;
        Ds(1, 1) = j.posy - l.posy;
        Ds(2, 1) = j.posz - l.posz;
        Ds(0, 2) = k.posx - l.posx;
        Ds(1, 2) = k.posy - l.posy;
        Ds(2, 2) = k.posz - l.posz;


        Eigen::Matrix<float,3,3> F = Ds * tetrahedrals[index].DmInverse;
        float PoissonRatio = 0.3;
        float YoungModulus = 5000;

        float miu = YoungModulus / (2.0 * (1.0 + PoissonRatio));
        float lamda = YoungModulus * PoissonRatio / ((1.0 + PoissonRatio) * (1.0 - 2.0 * PoissonRatio));
        //Added by Yuxin: compare different force models
        Eigen::Matrix<float,3,3> P;
        Eigen::Matrix<float, 3, 3> identityMatrix = Eigen::Matrix<float, 3, 3>::Identity();
        P.setZero();
        switch(forceModel) {
            //*******************Linear Approximation**********************//
            case LINEAR: {
                P = miu * (F + F.transpose() - 2 * identityMatrix) +
                    lamda * (F - identityMatrix).trace() * identityMatrix;
                break;
            }
            case SVKIRCHHOFF: {
                //TODO: Add St.Venant-Kirchhoff Model
                Eigen::Matrix<float, 3, 3> greenStrainTensor = 0.5*(F.transpose()*F - identityMatrix);
                P = F*(2*miu*greenStrainTensor + lamda*greenStrainTensor.trace()*identityMatrix);
                break;
            }
                //*******************Corotated Linear Elasticity Model********************//
            case COROTATED: {
                Eigen::JacobiSVD<Eigen::Matrix<float, 3, 3>> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
                Eigen::Matrix<float, 3, 3> U = svd.matrixU();
                Eigen::Matrix<float, 3, 3> V = svd.matrixV();

                // flip last column if det(U) < 0.0
                if (U.determinant() < 0.0) {
                    U(0, 2) = -U(0, 2);
                    U(1, 2) = -U(1, 2);
                    U(2, 2) = -U(2, 2);
                }

                // flip last column if det(V) < 0.0
                if (V.determinant() < 0.0) {
                    V(0, 2) = -V(0, 2);
                    V(1, 2) = -V(1, 2);
                    V(2, 2) = -V(2, 2);
                }

                Eigen::Matrix<float, 3, 3> R = U * V.transpose();

                float J = F.determinant();

                if (std::isnan(J)) {
                    std::cout << "J is nan" << std::endl;
                }

                Eigen::Matrix<float, 3, 3> JFInvTrans;
                JFInvTrans(0, 0) = F(1, 1) * F(2, 2) - F(1, 2) * F(2, 1);
                //JFInvTrans(0, 1) = -(F(1,0) * F(1,2) - F(2, 0) * F(2, 2));
                JFInvTrans(0, 1) = F(1, 2) * F(2, 0) - F(1, 0) * F(2, 2);
                JFInvTrans(0, 2) = F(1, 0) * F(2, 1) - F(1, 1) * F(2, 0);

                JFInvTrans(1, 0) = -(F(0, 1) * F(2, 2) - F(0, 2) * F(2, 1));
                JFInvTrans(1, 1) = F(0, 0) * F(2, 2) - F(0, 2) * F(2, 0);
                JFInvTrans(1, 2) = -(F(0, 0) * F(2, 1) - F(0, 1) * F(2, 0));

                JFInvTrans(2, 0) = F(0, 1) * F(1, 2) - F(0, 2) * F(1, 1);
                JFInvTrans(2, 1) = -(F(0, 0) * F(1, 2) - F(0, 2) * F(1, 0));
                JFInvTrans(2, 2) = F(0, 0) * F(1, 1) - F(0, 1) * F(1, 0);

                P = 2 * miu * (F - R) + lamda * (J - 1.0) * JFInvTrans;
                break;
            }
            case NEOHOOKEAN: {

                //TODO: Add Neohookean Force Model
                break;
            }
        }

        //Eigen::Matrix<float,3,3> identityMatrix = Eigen::Matrix<float,3,3>::Identity();
        //Eigen::Matrix<float,3,3> P = miu*(F + F.transpose()-2*identityMatrix) + lamda*(F-identityMatrix).trace()*identityMatrix;

        //*******************Corotated Linear Elasticity Model********************//

        /*Eigen::JacobiSVD<Eigen::Matrix<float,3,3>> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
        Eigen::Matrix<float,3,3> U = svd.matrixU();
        Eigen::Matrix<float,3,3> V = svd.matrixV();

        // flip last column if det(U) < 0.0
        if(U.determinant() < 0.0){
            U(0, 2) = -U(0 ,2);
            U(1, 2) = -U(1, 2);
            U(2, 2) = -U(2, 2);
        }

        // flip last column if det(V) < 0.0
        if(V.determinant() < 0.0){
            V(0, 2) = -V(0 ,2);
            V(1, 2) = -V(1, 2);
            V(2, 2) = -V(2, 2);
        }

        Eigen::Matrix<float,3,3> R = U * V.transpose();




        float J = F.determinant();

        if(std::isnan(J)) {
            std::cout << "J is nan" << std::endl;
        }

        Eigen::Matrix<float,3,3> JFInvTrans;
        JFInvTrans(0, 0) = F(1,1) * F(2, 2) - F(1, 2) * F(2, 1);
        //JFInvTrans(0, 1) = -(F(1,0) * F(1,2) - F(2, 0) * F(2, 2));
        JFInvTrans(0, 1) = F(1, 2) * F(2, 0) - F(1, 0) * F(2, 2);
        JFInvTrans(0, 2) = F(1, 0) * F(2, 1) - F(1, 1) * F(2, 0);

        JFInvTrans(1, 0) = -(F(0,1) * F(2, 2) - F(0, 2) * F(2, 1));
        JFInvTrans(1, 1) = F(0,0) * F(2,2) - F(0, 2) * F(2, 0);
        JFInvTrans(1, 2) = -(F(0, 0) * F(2, 1) - F(0, 1) * F(2, 0));

        JFInvTrans(2, 0) = F(0,1) * F(1, 2) - F(0, 2) * F(1, 1);
        JFInvTrans(2, 1) = -(F(0,0) * F(1,2) - F(0, 2) * F(1, 0));
        JFInvTrans(2, 2) = F(0, 0) * F(1, 1) - F(0, 1) * F(1, 0);

        Eigen::Matrix<float,3,3> P = 2 * miu * (F - R) + lamda * (J - 1.0) * JFInvTrans;*/
        //*******************Corotated Linear Elasticity Model********************//

        Eigen::Matrix<float,3,3> H = -tetrahedrals[index].volume * P * tetrahedrals[index].DmInverse.transpose();


        i.fx += H(0, 0); i.fy += H(1, 0); i.fz += H(2, 0);
        j.fx += H(0, 1); j.fy += H(1, 1); j.fz += H(2, 1);
        k.fx += H(0, 2); k.fy += H(1, 2); k.fz += H(2, 2);

        l.fx += - H(0, 0) - H(0, 1) - H(0, 2);
        l.fy += - H(1, 0) - H(1, 1) - H(1, 2);
        l.fz += - H(2, 0) - H(2, 1) - H(2, 2);


        particles[tetrahedrals[index].pIndex[0]] = i;
        particles[tetrahedrals[index].pIndex[1]] = j;
        particles[tetrahedrals[index].pIndex[2]] = k;
        particles[tetrahedrals[index].pIndex[3]] = l;
    }
}


void updateParticles(std::vector<particle>& particles, float simulationTimeStep){
    //TODO: update particles position and velocity

    int size = particles.size();

    for(int i = 0; i < size; i++){

        // update velocity
        particles[i].velx += simulationTimeStep * particles[i].fx / particles[i].mass;
        particles[i].vely += simulationTimeStep * particles[i].fy / particles[i].mass;
        particles[i].velz += simulationTimeStep * particles[i].fz / particles[i].mass;

        // update position
        particles[i].posx += simulationTimeStep * particles[i].velx;
        particles[i].posy += simulationTimeStep * particles[i].vely;
        particles[i].posz += simulationTimeStep * particles[i].velz;
    }
}

void writeBgeoFile(std::vector<particle>& particles, std::string fileName){
    //TODO: write the particle position and velocity in bgeo file
    Partio::ParticlesDataMutable* parts = Partio::create();
    Partio::ParticleAttribute posH, vH, mH, fH;

    mH   = parts->addAttribute("mass", Partio::VECTOR, 1);
    posH = parts->addAttribute("position", Partio::VECTOR, 3);
    vH   = parts->addAttribute("velocity", Partio::VECTOR, 3);
    fH = parts->addAttribute("force", Partio::VECTOR, 3);


    int size = particles.size();

    for (int i = 0; i < size; i++){
        int idx = parts->addParticle();
        float* m = parts->dataWrite<float>(mH, idx);
        float* p = parts->dataWrite<float>(posH, idx);
        float* v = parts->dataWrite<float>(vH, idx);
        float* f = parts->dataWrite<float>(fH, idx);

        m[0] = particles[i].mass;

        p[0] = particles[i].posx;
        p[1] = particles[i].posy;
        p[2] = particles[i].posz;

        v[0] = particles[i].velx;
        v[1] = particles[i].vely;
        v[2] = particles[i].velz;

        f[0] = particles[i].fx;
        f[1] = particles[i].fy;
        f[2] = particles[i].fz;
    }

    Partio::write(fileName.c_str(), *parts);
    parts->release();
}

void constrainedPoint(std::vector<particle>& particles, int index, float simulationTimeStep){
    //TODO: do a very simple circular motion
    int framesPerSecond = 24;
    int simulationTime = 30;
    particle p = particles[index];
    Eigen::Matrix<float,3,1> position;
    position << p.posx, p.posy, p.posz;
    float angular_velocity = 2 * M_2_PI / (framesPerSecond * simulationTime);
    p.posx = 0.5 * sin(simulationTimeStep * angular_velocity);
    p.posy = 0;
    p.posz = 0.5 * cos(simulationTimeStep * angular_velocity);
    p.velx = 0.5 * angular_velocity * cos(simulationTimeStep * angular_velocity);
    p.vely = 0;
    p.velz = -0.5 * angular_velocity * sin(simulationTimeStep * angular_velocity);
    particles[index] = p;
}

void kinematicCollision(std::vector<particle>& particles){

    // TODO: Add more complex kinematic collision here
    // Simply check the Y Plane so far

    int particleSize = particles.size();

    for(int i = 0; i < particleSize; i++){
        if(particles[i].posy < Y_COLLISION_PLANE){
            if (particles[i].vely < 0)
            {
                particles[i].velx = 0;
                particles[i].vely = 0;
                particles[i].velz = 0;
            }
            // particles[i].posy = Y_COLLISION_PLANE;
        }
    }
}

int main(int argc, char* argv[]){
    std::vector<particle> particles;
    std::vector<std::pair<int, int>> edges;
    std::vector<tetrahedral> tetrahedrals;
    std::vector<std::tuple<int, int, int>> faces;

    //Added by Yuxin for force model comparason
    std::vector<particle> particleLinearForce;
    std::vector<particle> particleSVKForce;

    //Parse the result .vtk file generated by tetGen program
    if(!parseFile("cubeTestHighDetail.1.vtk", particles, edges, tetrahedrals)){
        std::cout<<"file parse error!! check the vtk file"<<std::endl;
        return 0;
    }

    //Translate particles along x for 16 units, this may only applies to cube simulations
    for(unsigned int i = 0; i<particles.size(); i++){
        particleLinearForce.push_back(particle(particles[i].posx+16.0, particles[i].posy, particles[i].posz));
        particleLinearForce[i].mass = particles[i].mass;
        particleSVKForce.push_back(particle(particles[i].posx+32.0, particles[i].posy, particles[i].posz));
        particleSVKForce[i].mass = particles[i].mass;
    }

    if(!parseFaceFile("cubeTestHighDetail.1.face", faces)){
        std::cout<<"face file parse error!! check the face file"<<std::endl;
    }

    ///************Added by Yuxin for Debug Purpose************///
    //Write the parse result into .bego file to check points
    //writeBgeoFile(particles, "tetrahedralResult.bgeo");

    //Write the parse result into individual .poly file to check the shape of each individual tiny tetrahedral mesh
    //writeIndividualPolyFile("PolyFile/tetrahedrals",particles,tetrahedrals);

    //Write the parse result into .poly file so we can load it into Houdini to check the tetrahedral result
    //if(!writePolyFile("cubeTestOutput.poly", particles, edges)){
        //std::cout<<"write poly file error!! check the .poly file"<<std::endl;
    //}
    ///************Added by Yuxin for Debug Purpose************///

    //Start Simulation
    //Simulate 24 frames per second, let's run 10 seconds, so 240 frames in total.
    //For each frame, we take 10 timeStep, total of 2400 timeStep

    int simulationTime = 10; //30; //Seconds
    int framesPerSecond = 24;
    int timeStepCountPerFrame = 60;
    float simulationTimeStep = (1.0 / (float)framesPerSecond) / (float)timeStepCountPerFrame;


    int frameNum = 1;

    for(int i = 0; i < simulationTime; i++)
    {
        for(int j = 0; j < framesPerSecond; j++)
        {
            for(int k = 0; k < timeStepCountPerFrame; k++)
            {
                //*************TODO: eveluate force on each tetrahedrl************//
                evaluateForce(tetrahedrals, particles, COROTATED);
                evaluateForce(tetrahedrals, particleLinearForce, LINEAR);
                evaluateForce(tetrahedrals, particleSVKForce,SVKIRCHHOFF);

                //Added by Yuxin for Debug
                //printParticlePosition(particles, "before update");

                //*************TODO: update particle velocity and position*********//
                updateParticles(particles, simulationTimeStep);
                updateParticles(particleLinearForce, simulationTimeStep);
                updateParticles(particleSVKForce, simulationTimeStep);

                //Added by Yuxin for Debug
                //printParticlePosition(particles, "after update");


                //*************TODO: boundary and collision checking************//
                kinematicCollision(particles);
                kinematicCollision(particleLinearForce);
                kinematicCollision(particleSVKForce);
            }

            //*************TODO: write the particle position and velocity in bgeo file***********//
            // writeBgeoFile(particles, "simulationResult/femsimulation"+std::to_string(frameNum)+".bgeo");


            if(!writePolyFile("simulationResult/femSimulationCorotated" + std::to_string(frameNum)+ ".poly", particles, edges)){
                std::cout<<"write poly file error!! check the .poly file"<<std::endl;
            }

            if(!writePolyFile("simulationResult/femSimulationLinear" + std::to_string(frameNum)+ ".poly", particleLinearForce, edges)){
                std::cout<<"write poly file error!! check the .poly file"<<std::endl;
            }

            if(!writePolyFile("simulationResult/femSimulationSTK" + std::to_string(frameNum)+ ".poly", particleSVKForce, edges)){
                std::cout<<"write poly file error!! check the .poly file"<<std::endl;
            }

            //if(!writeObjFile("simulationResult/femsimulation" + std::to_string(frameNum)+ ".obj", particles, faces)){
                //std::cout<<"write obj file error!! check the .obj file"<<std::endl;
            //}

            std::cout << "Frame number is " << i*framesPerSecond + j << "!" << std::endl;

            frameNum++;
        }
    }

//    writeBgeoFile(particles, "femsimulation"+std::to_string(1)+".bgeo");

    return 0;
}